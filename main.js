!function(){"use strict";var e=1e-6,t="undefined"!=typeof Float32Array?Float32Array:Array,n=Math.PI/180;function i(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var o=function(e,t,n,i,o){var r,a=1/Math.tan(t/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(r=1/(i-o),e[10]=(o+i)*r,e[14]=2*o*i*r):(e[10]=-1,e[14]=-2*i),e};function r(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e,n,i){var o=new t(3);return o[0]=e,o[1]=n,o[2]=i,o}function s(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function c(e,t,n,i){return e[0]=t,e[1]=n,e[2]=i,e}function u(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function p(e,t){var n=t[0],i=t[1],o=t[2],r=n*n+i*i+o*o;return r>0&&(r=1/Math.sqrt(r)),e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}var f=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e};function l(){var e=new t(2);return t!=Float32Array&&(e[0]=0,e[1]=0),e}function d(e,n){var i=new t(2);return i[0]=e,i[1]=n,i}function m(e,t,n){return e[0]=t,e[1]=n,e}r(),function(){var e=l()}();const g=r(),h=a(0,1,0);class v{constructor({device:e,aspect:t=1,fov:n=75,near:o=.1,far:a=1e3}){this.device=e,this.buffer=e.createBuffer({size:32*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=t,this.fov=n,this.near=o,this.far=a,this.projectionMatrix=i(),this.viewMatrix=i(),this.position=r(),this.target=r()}setOrbit(e,t,n){const{position:i,target:o}=this,r=Math.sin(e)*n;u(i,o,c(g,r*Math.sin(t),Math.cos(e)*n,r*Math.cos(t))),this.updateView()}updateProjection(){const{device:e,buffer:t,projectionMatrix:i,aspect:r,fov:a,near:s,far:c}=this;o(i,a*n,r,s,c),e.queue.writeBuffer(t,0,i)}updateView(){const{device:t,buffer:n,viewMatrix:i,position:o,target:r}=this;var a,s,c,u,p,f,l,d,m,g,v,x,y,E,b,w,M,P,B,T,z,_,U;a=i,c=r,u=h,b=(s=o)[0],w=s[1],M=s[2],P=u[0],B=u[1],T=u[2],z=c[0],_=c[1],U=c[2],Math.abs(b-z)<e&&Math.abs(w-_)<e&&Math.abs(M-U)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(a):(v=b-z,x=w-_,y=M-U,p=B*(y*=E=1/Math.hypot(v,x,y))-T*(x*=E),f=T*(v*=E)-P*y,l=P*x-B*v,(E=Math.hypot(p,f,l))?(p*=E=1/E,f*=E,l*=E):(p=0,f=0,l=0),d=x*l-y*f,m=y*p-v*l,g=v*f-x*p,(E=Math.hypot(d,m,g))?(d*=E=1/E,m*=E,g*=E):(d=0,m=0,g=0),a[0]=p,a[1]=d,a[2]=v,a[3]=0,a[4]=f,a[5]=m,a[6]=x,a[7]=0,a[8]=l,a[9]=g,a[10]=y,a[11]=0,a[12]=-(p*b+f*w+l*M),a[13]=-(d*b+m*w+g*M),a[14]=-(v*b+x*w+y*M),a[15]=1),t.queue.writeBuffer(n,64,i)}}class x{constructor({camera:e,device:t,geometry:n,instances:i,samples:o}){this.geometry=n,this.instances=i,this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}]},{arrayStride:4*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"}]}],entryPoint:"main",module:t.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) scale : f32,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n@vertex\nfn main(explosion : VertexInput) -> VertexOutput {\n  let position : vec3<f32> = explosion.position * explosion.scale + explosion.origin;\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.normal = explosion.normal;\n  out.depth = -mvPosition.z;\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@fragment\nfn main(explosion : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = vec4<f32>(1);\n  output.data = vec4<f32>(normalize(explosion.normal), explosion.depth);\n  return output;\n}\n"}),targets:[{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:o}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}}]})}render(e){const{bindings:t,instances:n,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,t),e.setIndexBuffer(i.index,"uint16"),e.setVertexBuffer(0,i.vertex),e.setVertexBuffer(1,n,20),e.drawIndexedIndirect(n,0)}}class y{constructor(){this.look={state:d(.3*Math.PI,0),target:d(.3*Math.PI,0)},this.pointer={movement:l(),position:l()},this.zoom={state:.7,target:.7},this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onMouseWheel=this.onMouseWheel.bind(this),window.addEventListener("mousedown",this.onMouseDown,!1),window.addEventListener("mousemove",this.onMouseMove,!1),window.addEventListener("mouseup",this.onMouseUp,!1),window.addEventListener("wheel",this.onMouseWheel,{passive:!1})}destroy(){window.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),window.removeEventListener("wheel",this.onMouseWheel)}onMouseDown({button:e}){const{pointer:t}=this;t.isDown=0===e}onMouseMove({clientX:e,clientY:t,movementX:n,movementY:i}){const{sensitivity:o}=y,{pointer:{movement:r,position:a}}=this;r[0]-=n*o.look,r[1]-=i*o.look,m(a,e/window.innerWidth*2-1,-t/window.innerHeight*2+1)}onMouseUp({button:e}){const{pointer:t}=this;0===e&&(t.isDown=!1)}onMouseWheel(e){e.ctrlKey&&e.preventDefault();const{sensitivity:t,minZoom:n,zoomRange:i}=y,{zoom:o}=this,r=Math.min(Math.max((Math.log(o.target)-n)/i+e.deltaY*t.zoom,0),1);o.target=Math.exp(n+r*i)}update(e){const{minPhi:t,maxPhi:n}=y,{pointer:i,look:o,zoom:r}=this;i.isDown&&(o.target[1]+=i.movement[0],o.target[0]=Math.min(Math.max(o.target[0]+i.movement[1],t),n));const a=1-Math.exp(-10*e);var s,c,u,p,f,l;s=o.state,c=o.state,u=o.target,p=a,f=c[0],l=c[1],s[0]=f+p*(u[0]-f),s[1]=l+p*(u[1]-l),r.state=r.state*(1-a)+r.target*a,m(i.movement,0,0)}}y.sensitivity={look:.003,zoom:3e-4},y.minPhi=.01,y.maxPhi=.5*Math.PI-.01,y.minZoom=Math.log(.1),y.maxZoom=Math.log(1.5),y.zoomRange=y.maxZoom-y.minZoom;const E=({position:e})=>`\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) origin : vec2<f32>,\n  @location(2) light : f32,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) depth : f32,\n  @location(1) fog : f32,\n  @location(2) light : f32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\nconst origin : vec3<f32> = vec3<f32>(${e[0]}, ${e[1]}, ${e[2]});\n\n@vertex\nfn main(vertex : VertexInput) -> VertexOutput {\n  let position : vec3<f32> = vertex.position + vec3<f32>(vertex.origin.x, 0, vertex.origin.y);\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position + origin, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.depth = -mvPosition.z;\n  out.fog = length(position);\n  out.light = 0.75 + vertex.light * 0.25;\n  return out;\n}\n`;class b{constructor({camera:e,device:t,position:n,samples:i}){this.device=t,this.geometry=(e=>{const t=e.createBuffer({mappedAtCreation:!0,size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX});return new Float32Array(t.getMappedRange()).set([-.5,0,.5,.5,0,.5,.5,0,-.5,.5,0,-.5,-.5,0,-.5,-.5,0,.5]),t.unmap(),t})(t),this.instances=(e=>{const t=e.createBuffer({mappedAtCreation:!0,size:4327203*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX}),n=new Float32Array(t.getMappedRange());for(let e=0,t=-600;t<=600;t++)for(let i=-600;i<=600;i++,e+=3)n.set([i+.5,t+.5,Math.random()],e);return t.unmap(),t})(t),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]},{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"float32x2"},{shaderLocation:2,offset:2*Float32Array.BYTES_PER_ELEMENT,format:"float32"}]}],entryPoint:"main",module:t.createShaderModule({code:E({position:n})})},fragment:{entryPoint:"main",module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) depth : f32,\n  @location(1) fog : f32,\n  @location(2) light : f32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n}\n\nconst fogDensity : f32 = 0.005;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = vec4<f32>(vec3<f32>(0.1, 0.2, 0.3) * face.light, exp(-fogDensity * fogDensity * face.fog * face.fog) * 0.7);\n  return output;\n}\n"}),targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}}},{format:"rgba16float",writeMask:0}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:i}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}}]})}render(e){const{bindings:t,geometry:n,instances:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,t),e.setVertexBuffer(0,n),e.setVertexBuffer(1,i),e.draw(6,1442401,0,0)}}class w{constructor({camera:e,device:t,instances:n,samples:i}){this.geometry=(e=>{const t=e.createBuffer({mappedAtCreation:!0,size:36*Uint16Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDEX}),n=new Uint16Array(t.getMappedRange());for(let e=0,t=0,i=0;e<6;e++,t+=6,i+=4)n[t]=i,n[t+1]=i+1,n[t+2]=i+2,n[t+3]=i+2,n[t+4]=i+3,n[t+5]=i;t.unmap();const i=e.createBuffer({mappedAtCreation:!0,size:144*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX});return new Float32Array(i.getMappedRange()).set([-.1,-.1,.1,0,0,1,.1,-.1,.1,0,0,1,.1,.1,.1,0,0,1,-.1,.1,.1,0,0,1,.1,-.1,-.1,0,0,-1,-.1,-.1,-.1,0,0,-1,-.1,.1,-.1,0,0,-1,.1,.1,-.1,0,0,-1,-.1,.1,.1,0,1,0,.1,.1,.1,0,1,0,.1,.1,-.1,0,1,0,-.1,.1,-.1,0,1,0,-.1,-.1,-.1,0,-1,0,.1,-.1,-.1,0,-1,0,.1,-.1,.1,0,-1,0,-.1,-.1,.1,0,-1,0,.1,-.1,.1,1,0,0,.1,-.1,-.1,1,0,0,.1,.1,-.1,1,0,0,.1,.1,.1,1,0,0,-.1,-.1,-.1,-1,0,0,-.1,-.1,.1,-1,0,0,-.1,.1,.1,-1,0,0,-.1,.1,-.1,-1,0,0]),i.unmap(),{index:t,vertex:i}})(t),this.instances=n,this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}]},{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}]}],entryPoint:"main",module:t.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) direction : vec3<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\nconst worldUp : vec3<f32> = vec3<f32>(0, 1, 0);\n\nfn getRotation(direction : vec3<f32>) -> mat3x3<f32> {\n  let xaxis : vec3<f32> = normalize(cross(worldUp, direction));\n  let yaxis : vec3<f32> = normalize(cross(direction, xaxis));\n  return mat3x3<f32>(xaxis, yaxis, direction);\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n@vertex\nfn main(projectile : VertexInput) -> VertexOutput {\n  let rotation : mat3x3<f32> = getRotation(projectile.direction);\n  let position : vec3<f32> = rotation * (projectile.position * vec3<f32>(1, 1, 5)) + projectile.origin;\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.normal = normalize(rotation * projectile.normal);\n  out.depth = -mvPosition.z;\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@fragment\nfn main(projectile : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = vec4<f32>(1);\n  output.data = vec4<f32>(normalize(projectile.normal), projectile.depth);\n  return output;\n}\n"}),targets:[{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:i}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}}]})}render(e){const{bindings:t,instances:n,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,t),e.setIndexBuffer(i.index,"uint16"),e.setVertexBuffer(0,i.vertex),e.setVertexBuffer(1,n,20),e.drawIndexedIndirect(n,0)}}class M{constructor({device:e,format:t}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.geometry=(e=>{const t=e.createBuffer({mappedAtCreation:!0,size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX});return new Float32Array(t.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),t.unmap(),t})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}],entryPoint:"main",module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"})},fragment:{entryPoint:"main",module:e.createShaderModule({code:"\n@group(0) @binding(0) var colorTexture : texture_2d<f32>;\n@group(0) @binding(1) var dataTexture : texture_2d<f32>;\n\nconst edgeColor : vec3<f32> = vec3<f32>(0, 0, 0);\nconst edgeIntensity : f32 = 0.2;\nconst depthScale : f32 = 0.3;\nconst normalScale : f32 = 0.3;\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edge(pixel : vec2<i32>) -> f32 {\n  let pixelCenter : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let pixelLeft : vec4<f32> = textureLoad(dataTexture, pixel - offset.xz, 0);\n  let pixelRight : vec4<f32> = textureLoad(dataTexture, pixel + offset.xz, 0);\n  let pixelUp : vec4<f32> = textureLoad(dataTexture, pixel + offset.zy, 0);\n  let pixelDown : vec4<f32> = textureLoad(dataTexture, pixel - offset.zy, 0);\n  let edge : vec4<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return clamp(max((edge.x + edge.y + edge.z) * normalScale, edge.w * depthScale), 0, 1);\n}\n\nfn linearTosRGB(linear : vec3<f32>) -> vec3<f32> {\n  if (all(linear <= vec3<f32>(0.0031308))) {\n    return linear * 12.92;\n  }\n  return (pow(abs(linear), vec3<f32>(1.0/2.4)) * 1.055) - vec3<f32>(0.055);\n}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  let pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  color = mix(color, edgeColor, edge(pixel) * edgeIntensity);\n  return vec4<f32>(linearTosRGB(color), 1);\n}\n"}),targets:[{format:t}]},primitive:{topology:"triangle-list"}})}bindTextures([e,t]){const{device:n,pipeline:i}=this;this.bindings=n.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:e.resolveTarget},{binding:1,resource:t.resolveTarget}]})}render(e,t){const{bindings:n,descriptor:i,geometry:o,pipeline:r}=this;i.colorAttachments[0].view=t;const a=e.beginRenderPass(i);a.setPipeline(r),a.setBindGroup(0,n),a.setVertexBuffer(0,o),a.draw(6,1,0,0),a.end()}}class P{constructor({adapter:e,camera:t,device:n,samples:i=4}){this.camera=t,this.device=n,this.samples=i;const o=navigator.gpu.getPreferredCanvasFormat(e);this.canvas=document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:n,format:o}),this.descriptor={colorAttachments:[{clearValue:{r:.05,g:.075,b:.125,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},this.postprocessing=new M({device:n,format:o}),this.scene=[],this.textures=new Map}render(e){const{context:t,descriptor:n,postprocessing:i,scene:o}=this,r=e.beginRenderPass(n);o.forEach((e=>e.render(r))),r.end(),i.render(e,t.getCurrentTexture().createView())}setBackground(e,t,n){const{descriptor:{colorAttachments:[{clearValue:i}]}}=this;i.r=e,i.g=t,i.b=n}setSize(e,t){const{camera:n,canvas:i,descriptor:o,postprocessing:r}=this,a=window.devicePixelRatio||1,s=[Math.floor(e*a),Math.floor(t*a)];i.width=s[0],i.height=s[1],i.style.width=`${e}px`,i.style.height=`${t}px`,n.aspect=e/t,n.updateProjection(),this.updateTexture(o.colorAttachments[0],"rgba16float","color",s),this.updateTexture(o.colorAttachments[1],"rgba16float","data",s),this.updateTexture(o.depthStencilAttachment,"depth24plus","depth",s,!1),r.bindTextures(o.colorAttachments)}updateTexture(e,t,n,i,o=!0){const{device:r,samples:a,textures:s}=this,c=s.get(n);c&&c.forEach((e=>e.destroy())),s.set(n,[a,...o?[1]:[]].map((n=>{const o=r.createTexture({format:t,sampleCount:n,size:i,usage:GPUTextureUsage.RENDER_ATTACHMENT|(1===n?GPUTextureUsage.TEXTURE_BINDING:0)});return 1===n?e.resolveTarget=o.createView():e.view=o.createView(),o})))}}const B=({size:e})=>`\nstruct Faces {\n  vertexCount : u32,\n  instanceCount : atomic<u32>,\n  firstVertex : u32,\n  firstInstance : u32,\n  data : array<f32>\n}\n\n@group(0) @binding(0) var<storage, read> data : array<u32>;\n@group(0) @binding(1) var<storage, read_write> faces : Faces;\n\nconst faceNormals = array<vec3<i32>, 6>(\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 1, 0),\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(0, 0, -1),\n);\n\nconst size : vec3<i32> = vec3<i32>(${e[0]}, ${e[1]}, ${e[2]});\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * size.x * size.y + pos.y * size.x + pos.x);\n}\n\nfn getValue(pos : vec3<i32>) -> u32 {\n  if (pos.y < 0) {\n    return 1;\n  }\n  if (any(pos < vec3<i32>(0)) || any(pos >= size)) {\n    return 0;\n  }\n  return data[getVoxel(pos)];\n}\n\nfn pushFace(pos : vec3<i32>, face : i32, value : u32) {\n  let offset : u32 = atomicAdd(&faces.instanceCount, 1) * 4;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = f32(i32(value - 1) * 6 + face);\n}\n\n@compute @workgroup_size(64, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(id);\n  if (any(pos >= size)) {\n    return;\n  }\n  let value = getValue(pos);\n  if (value == 0) {\n    return;\n  }\n  for (var face : i32 = 0; face < 6; face++) {\n    let npos : vec3<i32> = pos + faceNormals[face];\n    if (getValue(npos) == 0) {\n      pushFace(pos, face, value);\n    }\n  }\n}\n`;class T{constructor({data:e,device:t,faces:n,size:i}){this.pipeline=t.createComputePipeline({layout:"auto",compute:{module:t.createShaderModule({code:B({size:i})}),entryPoint:"main"}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e}},{binding:1,resource:{buffer:n}}]}),this.faces=n,this.workgroups=new Uint32Array([Math.ceil(i[0]/64),Math.ceil(i[1]/4),i[2]])}compute(e){const{bindings:t,faces:n,pipeline:i,workgroups:o}=this;e.clearBuffer(n,4,4);const r=e.beginComputePass();r.setPipeline(i),r.setBindGroup(0,t),r.dispatchWorkgroups(o[0],o[1],o[2]),r.end()}}const z=({count:e,instancesPerMesh:t})=>`\nstruct Instances {\n  indexCount : u32,\n  instanceCount : atomic<u32>,\n  firstIndex : u32,\n  baseVertex : u32,\n  firstInstance : u32,\n  data : array<f32, ${e*t*4}>,\n}\n\n@group(0) @binding(0) var<storage, read_write> instances : Instances;\n@group(0) @binding(1) var<uniform> meshes : array<vec4<f32>, ${e}>;\n@group(0) @binding(2) var<uniform> normals : array<vec3<f32>, ${t}>;\n\n@compute @workgroup_size(${t})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let offset : u32 = (id.y * ${t} + id.x) * 4;\n  let step : f32 = meshes[id.y].w;\n  let pos : vec3<f32> = meshes[id.y].xyz + normals[id.x] * step * 4;\n  instances.data[offset] = pos.x;\n  instances.data[offset + 1] = pos.y;\n  instances.data[offset + 2] = pos.z;\n  instances.data[offset + 3] = (1 - step) * 4;\n  atomicAdd(&instances.instanceCount, 1);\n}\n`;class _{constructor({count:e,device:t,explosions:n}){const i=t.createBuffer({mappedAtCreation:!0,size:4*n.instancesPerMesh*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),o=new Float32Array(i.getMappedRange()),a=r();for(let e=0,t=0;e<n.instancesPerMesh;e++,t+=4)c(a,Math.random()-.5,Math.random()-.5,Math.random()-.5),p(a,a),s=a,u=a,f=1.5-Math.random(),s[0]=u[0]*f,s[1]=u[1]*f,s[2]=u[2]*f,o.set(a,t);var s,u,f;i.unmap(),this.pipeline=t.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:t.createShaderModule({code:z({count:e,instancesPerMesh:n.instancesPerMesh})})}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.instances}},{binding:1,resource:{buffer:n.meshes}},{binding:2,resource:{buffer:i}}]}),this.workgroups=n.workgroups}compute(e){const{bindings:t,pipeline:n,workgroups:i}=this;e.setPipeline(n),e.setBindGroup(0,t),e.dispatchWorkgroupsIndirect(i,0)}}const U=({count:e})=>`\nstruct Explosion {\n  enabled: u32,\n  position: vec3<f32>,\n  step: f32,\n}\n\nstruct Projectile {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  iteration: u32,\n  state: u32,\n}\n\n@group(0) @binding(0) var<uniform> delta : f32;\n@group(0) @binding(1) var<uniform> projectiles : array<Projectile, ${e}>;\n@group(0) @binding(2) var<storage, read_write> meshes : array<vec4<f32>, ${e}>;\n@group(0) @binding(3) var<storage, read_write> explosions : array<Explosion, ${e}>;\n@group(0) @binding(4) var<storage, read_write> workgroups : array<atomic<u32>, 3>;\n\n@compute @workgroup_size(${Math.min(e,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= ${e}) {\n    return;\n  }\n  if (projectiles[id.x].state == 2) {\n    explosions[id.x].enabled = 1;\n    explosions[id.x].position = projectiles[id.x].position;\n    explosions[id.x].step = 0;\n  }\n  if (explosions[id.x].enabled != 1) {\n    return;\n  }\n  explosions[id.x].step += delta * 4;\n  if (explosions[id.x].step > 1) {\n    explosions[id.x].enabled = 0;\n    return;\n  }\n  var offset : u32 = atomicAdd(&workgroups[1], 1);\n  meshes[offset] = vec4<f32>(explosions[id.x].position, explosions[id.x].step);\n}\n`;class R{constructor({count:e,delta:t,device:n,explosions:i,projectiles:o}){this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:U({count:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:o.state}},{binding:2,resource:{buffer:i.meshes}},{binding:3,resource:{buffer:i.state}},{binding:4,resource:{buffer:i.workgroups}}]}),this.workgroups=Math.ceil(e/256)}compute(e){const{bindings:t,pipeline:n,workgroups:i}=this;e.setPipeline(n),e.setBindGroup(0,t),e.dispatchWorkgroups(i)}}const A=({count:e,size:t})=>`\nstruct Projectile {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  iteration: u32,\n  state: u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> projectiles : array<Projectile, ${e}>;\n@group(0) @binding(1) var<storage, read_write> data : array<atomic<u32>>;\n\nconst size : vec3<i32> = vec3<i32>(${t[0]}, ${t[1]}, ${t[2]});\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * size.x * size.y + pos.y * size.x + pos.x);\n}\n\nconst neighbors = array<vec3<i32>, 6>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 0, -1),\n  vec3<i32>(0, 1, 0),\n);\n\nfn collide(id : u32) {\n  let pos : vec3<i32> = vec3<i32>(floor(projectiles[id].position));\n  if (any(pos < vec3<i32>(0)) || any(pos >= size)) {\n    return;\n  }\n  if (atomicMin(&data[getVoxel(pos)], 0) != 0) {\n    projectiles[id].state = 2;\n  }\n}\n\nfn detonate(id : u32) {\n  let pos : vec3<i32> = vec3<i32>(floor(projectiles[id].position));\n  let radius : i32 = 4;\n  for (var z : i32 = -radius; z <= radius; z++) {\n    for (var y : i32 = -radius; y <= radius; y++) {\n      for (var x : i32 = -radius; x <= radius; x++) {\n        let npos : vec3<i32> = pos + vec3<i32>(x, y, z);\n        if (\n          any(npos < vec3<i32>(0))\n          || any(npos >= size)\n          || length(vec3<f32>(f32(x), f32(y), f32(z))) > (f32(radius) - 0.5)\n        ) {\n          continue;\n        }\n        atomicMin(&data[getVoxel(npos)], 0);\n      }\n    }\n  }\n}\n\n@compute @workgroup_size(${Math.min(e,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= ${e}) {\n    return;\n  }\n  switch (projectiles[id.x].state) {\n    default {}\n    case 1 {\n      collide(id.x);\n    }\n    case 3 {\n      detonate(id.x);\n    }\n  }\n}\n`;class S{constructor({count:e,data:t,device:n,projectiles:i,size:o}){this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:A({count:e,size:o})}),entryPoint:"main"}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:i.state}},{binding:1,resource:{buffer:t}}]}),this.workgroups=Math.ceil(e/256)}compute(e){const{bindings:t,pipeline:n,workgroups:i}=this;e.setPipeline(n),e.setBindGroup(0,t),e.dispatchWorkgroups(i)}}const G=({count:e})=>`\nstruct Input {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  enabled: atomic<u32>,\n}\n\nstruct Instances {\n  indexCount : u32,\n  instanceCount : atomic<u32>,\n  firstIndex : u32,\n  baseVertex : u32,\n  firstInstance : u32,\n  data : array<f32, ${6*e}>,\n}\n\nstruct Projectile {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  iteration: u32,\n  state: u32,\n}\n\n\n@group(0) @binding(0) var<uniform> delta : f32;\n@group(0) @binding(1) var<storage, read_write> input : Input;\n@group(0) @binding(2) var<storage, read_write> instances : Instances;\n@group(0) @binding(3) var<storage, read_write> projectiles : array<Projectile, ${e}>;\n\nfn instanceProjectile(position : vec3<f32>, direction : vec3<f32>) {\n  let offset : u32 = atomicAdd(&instances.instanceCount, 1) * 6;\n  instances.data[offset] = position.x;\n  instances.data[offset + 1] = position.y;\n  instances.data[offset + 2] = position.z;\n  instances.data[offset + 3] = direction.x;\n  instances.data[offset + 4] = direction.y;\n  instances.data[offset + 5] = direction.z;\n}\n\n@compute @workgroup_size(${Math.min(e,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= ${e}) {\n    return;\n  }\n  switch (projectiles[id.x].state) {\n    default {}\n    case 1 {\n      projectiles[id.x].iteration++;\n      if (projectiles[id.x].iteration > 128) {\n        projectiles[id.x].state = 0;\n        return;\n      }\n      let direction : vec3<f32> = projectiles[id.x].direction;\n      projectiles[id.x].position += direction * delta * 60;\n      instanceProjectile(projectiles[id.x].position, direction);\n      if (projectiles[id.x].position.y <= 0) {\n        projectiles[id.x].state = 2;\n      }\n      return;\n    }\n    case 2 {\n      projectiles[id.x].state = 3;\n      return;\n    }\n    case 3 {\n      projectiles[id.x].state = 0;\n    }\n  }\n  if (atomicMin(&input.enabled, 0) != 0) {\n    projectiles[id.x].position = input.position; \n    projectiles[id.x].direction = input.direction; \n    projectiles[id.x].iteration = 0;\n    projectiles[id.x].state = 1;\n  }\n}\n`;class L{constructor({count:e,delta:t,device:n,projectiles:i}){{const e=new Float32Array(8);this.input={buffer:n.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),data:e.buffer,position:e.subarray(0,3),direction:e.subarray(4,7),enabled:new Uint32Array(e.buffer,28,1)}}this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:G({count:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:this.input.buffer}},{binding:2,resource:{buffer:i.instances}},{binding:3,resource:{buffer:i.state}}]}),this.workgroups=Math.ceil(e/256)}compute(e){const{bindings:t,pipeline:n,workgroups:i}=this;e.setPipeline(n),e.setBindGroup(0,t),e.dispatchWorkgroups(i)}}const F=({size:e})=>`\nstruct Uniforms {\n  offset : u32,\n  y : i32,\n}\n\n@group(0) @binding(0) var<storage, read_write> uniforms : Uniforms;\n\n@compute @workgroup_size(1)\nfn main() {\n  uniforms.offset += 1;\n  uniforms.y = (uniforms.y + 1) % ${e[1]-1};\n}\n`;class C{constructor({device:e,size:t,uniforms:n}){this.pipeline=e.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:e.createShaderModule({code:F({size:t})})}}),this.bindings=e.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n}}]})}compute(e){const{bindings:t,pipeline:n}=this;e.setPipeline(n),e.setBindGroup(0,t),e.dispatchWorkgroups(1)}}const j=({size:e})=>`\nstruct Uniforms {\n  offset : atomic<u32>,\n  y : i32,\n}\n\n@group(0) @binding(0) var<storage, read_write> data : array<atomic<u32>>;\n@group(0) @binding(1) var<storage, read_write> uniforms : Uniforms;\n\nconst size : vec3<i32> = vec3<i32>(${e[0]}, ${e[1]}, ${e[2]});\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * size.x * size.y + pos.y * size.x + pos.x);\n}\n\nconst neighbors = array<vec3<i32>, 5>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(0, -1, -1),\n  vec3<i32>(-1, -1, 0),\n  vec3<i32>(0, -1, 1),\n  vec3<i32>(1, -1, 0),\n);\n\n@compute @workgroup_size(64, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(i32(id.x), uniforms.y + 1, i32(id.y));\n  if (any(pos >= size)) {\n    return;\n  }\n  let voxel = getVoxel(pos);\n  let value = atomicLoad(&data[voxel]);\n  if (value == 0) {\n    return;\n  }\n  let o : u32 = atomicAdd(&uniforms.offset, 1);\n  for (var n : u32 = 0; n < 5; n++) {\n    var ni : u32 = 0;\n    if (n > 0) {\n      ni = 1 + ((n + o) % 4);\n    }\n    let npos = pos + neighbors[ni];\n    if (any(npos < vec3<i32>(0)) || any(npos >= size)) {\n      continue;\n    }\n    let nvoxel = getVoxel(npos);\n    if (atomicCompareExchangeWeak(&data[nvoxel], 0, value).exchanged) {\n      atomicCompareExchangeWeak(&data[voxel], value, 0);\n      break;\n    }\n  }\n}\n`;class I{constructor({data:e,device:t,size:n,uniforms:i}){this.pipeline=t.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:t.createShaderModule({code:j({size:n})})}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e}},{binding:1,resource:{buffer:i}}]}),this.workgroups=new Uint32Array([Math.ceil(n[0]/64),Math.ceil(n[2]/4)])}compute(e){const{bindings:t,pipeline:n,workgroups:i}=this;e.setPipeline(n),e.setBindGroup(0,t),e.dispatchWorkgroups(i[0],i[1])}}class V{constructor({count:e=128,data:t,device:n,size:i}){this.device=n;{const e=new Float32Array(1);this.delta={buffer:n.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),data:e}}{const t=64,i=n.createBuffer({mappedAtCreation:!0,size:5*Uint32Array.BYTES_PER_ELEMENT+e*t*4*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});new Uint32Array(i.getMappedRange(0,Uint32Array.BYTES_PER_ELEMENT))[0]=36,i.unmap();const o=n.createBuffer({size:4*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.UNIFORM}),r=n.createBuffer({size:8*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),a=n.createBuffer({mappedAtCreation:!0,size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});new Uint32Array(a.getMappedRange()).set([1,0,1]),a.unmap(),this.explosions={instances:i,instancesPerMesh:t,meshes:o,state:r,workgroups:a}}{const t=n.createBuffer({mappedAtCreation:!0,size:5*Uint32Array.BYTES_PER_ELEMENT+6*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});new Uint32Array(t.getMappedRange(0,Uint32Array.BYTES_PER_ELEMENT))[0]=36,t.unmap();const i=n.createBuffer({size:12*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.UNIFORM});this.projectiles={instances:t,state:i}}{const e=n.createBuffer({mappedAtCreation:!0,size:2*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE});new Int32Array(e.getMappedRange())[1]=i[1]-2,e.unmap(),this.sand={uniforms:e}}this.pipelines={explosions:{mesh:new _({count:e,device:n,explosions:this.explosions}),step:new R({count:e,delta:this.delta,device:n,explosions:this.explosions,projectiles:this.projectiles})},projectiles:{collide:new S({count:e,data:t,device:n,projectiles:this.projectiles,size:i}),step:new L({count:e,delta:this.delta,device:n,explosions:this.explosions,projectiles:this.projectiles})},sand:{setup:new C({device:n,size:i,uniforms:this.sand.uniforms}),step:new I({data:t,device:n,size:i,uniforms:this.sand.uniforms})}},this.size=i}compute(e,t){const{delta:{buffer:n,data:i},device:o,pipelines:{explosions:r,projectiles:a,sand:s},size:c}=this;i[0]=t,o.queue.writeBuffer(n,0,i),e.clearBuffer(this.explosions.instances,4,4),e.clearBuffer(this.explosions.workgroups,4,4),e.clearBuffer(this.projectiles.instances,4,4);const u=e.beginComputePass();for(let e=0;e<c[1]-1;e++)s.setup.compute(u),s.step.compute(u);r.step.compute(u),r.mesh.compute(u),a.step.compute(u),a.collide.compute(u),u.end()}shoot(e,t){const{device:n,pipelines:{projectiles:{step:{input:i}}}}=this;s(i.position,t),s(i.direction,e),i.enabled[0]=1,n.queue.writeBuffer(i.buffer,0,i.data)}}const O=({count:e,size:t})=>`\n@group(0) @binding(0) var<storage, read_write> data : array<u32>;\n@group(0) @binding(1) var<uniform> input : array<vec4<i32>, ${e}>;\n\nconst size : vec3<i32> = vec3<i32>(${t[0]}, ${t[1]}, ${t[2]});\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * size.x * size.y + pos.y * size.x + pos.x);\n}\n\n@compute @workgroup_size(${Math.min(e,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= ${e}) {\n    return;\n  }\n  let i = input[id.x];\n  let radius : i32 = 3;\n  for (var x : i32 = -radius; x <= radius; x++) {\n    for (var z : i32 = -radius; z <= radius; z++) {\n      let npos : vec3<i32> = i.xyz + vec3<i32>(x, 0, z);\n      if (\n        any(npos < vec3<i32>(0))\n        || any(npos >= size)\n        || length(vec3<f32>(f32(x), 0, f32(z))) > (f32(radius) - 0.5)\n      ) {\n        continue;\n      }\n      let voxel = getVoxel(npos);\n      if (data[voxel] == 0) {\n        data[voxel] = u32(i.w);\n      }\n    }\n  }\n}\n`;class N{constructor({count:e=4,data:t,device:n,size:i}){this.input={buffer:n.createBuffer({size:4*e*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),data:new Int32Array(4*e)},this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:O({count:e,size:i})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:this.input.buffer}}]}),this.size=i,this.workgroups=Math.ceil(e/256)}compute(e){const{bindings:t,pipeline:n,workgroups:i}=this,o=e.beginComputePass();o.setPipeline(n),o.setBindGroup(0,t),o.dispatchWorkgroups(i),o.end()}}class k{constructor({device:e,size:t}){this.data=e.createBuffer({size:t[0]*t[1]*t[2]*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),this.faces=e.createBuffer({size:4*Uint32Array.BYTES_PER_ELEMENT+4*Math.ceil(t[0]*t[1]*t[2]*.5)*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),e.queue.writeBuffer(this.faces,0,new Uint32Array([6])),this.mesher=new T({data:this.data,device:e,faces:this.faces,size:t}),this.simulation=new V({data:this.data,device:e,size:t}),this.update=new N({data:this.data,device:e,size:t})}compute(e,t){const{mesher:n,simulation:i}=this;i.compute(e,t),n.compute(e)}}class Y{constructor({camera:e,device:t,faces:n,samples:i}){this.device=t,this.faces=n,this.geometry=(e=>{const t=e.createBuffer({mappedAtCreation:!0,size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX});return new Float32Array(t.getMappedRange()).set([-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,.5,.5,.5,-.5,.5,.5,-.5,-.5,.5]),t.unmap(),t})(t),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]},{arrayStride:4*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"float32x4"}]}],entryPoint:"main",module:t.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) instance : vec4<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) color : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) depth : f32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\nconst faces = array<mat3x3<f32>, 6>(\n  mat3x3<f32>(vec3<f32>(1, 0, 0), vec3<f32>(0, 1, 0), vec3<f32>(0, 0, 1)),\n  mat3x3<f32>(vec3<f32>(1, 0, 0), vec3<f32>(0, 0, -1), vec3<f32>(0, 1, 0)),\n  mat3x3<f32>(vec3<f32>(1, 0, 0), vec3<f32>(0, 0, 1), vec3<f32>(0, -1, 0)),\n  mat3x3<f32>(vec3<f32>(0, 0, 1), vec3<f32>(0, 1, 0), vec3<f32>(-1, 0, 0)),\n  mat3x3<f32>(vec3<f32>(0, 0, -1), vec3<f32>(0, 1, 0), vec3<f32>(1, 0, 0)),\n  mat3x3<f32>(vec3<f32>(-1, 0, 0), vec3<f32>(0, 1, 0), vec3<f32>(0, 0, -1)),\n);\n\nfn hue2Rgb(p : f32, q : f32, t : f32) -> f32 {\n  var h : f32 = t;\n  if (h < 0) { h += 1; }\n  if (h > 1) { h -= 1; }\n  if (h < 1 / 6.0) { return p + (q - p) * 6 * h; }\n  if (h < 1 / 2.0) { return q; }\n  if (h < 2 / 3.0) { return p + (q - p) * (2.0 / 3.0 - h) * 6; }\n  return p;\n}\n\nfn hsl2Rgb(h : f32, s: f32, l: f32) -> vec3<f32> {\n  var rgb : vec3<f32> = vec3<f32>(0, 0, 0);\n  var q : f32;\n  if (l < 0.5) {\n    q = l * (1 + s);\n  } else {\n    q = l + s - l * s;\n  }\n  var p : f32 = 2 * l - q;\n  rgb.r = hue2Rgb(p, q, h + 1 / 3.0);\n  rgb.g = hue2Rgb(p, q, h);\n  rgb.b = hue2Rgb(p, q, h - 1 / 3.0);\n  return rgb;\n}\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  let model : mat3x3<f32> = faces[i32(voxel.instance.w % 6)];\n  let position : vec3<f32> = model * voxel.position + voxel.instance.xyz;\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  let s = max(smoothstep(0, 6, position.y), 0.1);\n  out.color = hsl2Rgb(floor(voxel.instance.w / 6) / 360, 0.4, 0.4);\n  if (s < 1) {\n    out.color = mix(vec3<f32>(0.1, 0.2, 0.3) * s, out.color, s);\n  }\n  out.normal = model[2];\n  out.depth = -mvPosition.z;\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) color : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) depth : f32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = vec4<f32>(face.color, 1);\n  output.data = vec4<f32>(normalize(face.normal), face.depth);\n  return output;\n}\n"}),targets:[{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:i}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}}]})}render(e){const{bindings:t,faces:n,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,t),e.setVertexBuffer(0,i),e.setVertexBuffer(1,n,16),e.drawIndirect(n,0)}}(async()=>{if(!navigator.gpu)throw new Error("WebGPU support");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGPU adapter");const t=await e.requestDevice(),n=t.createShaderModule({code:"const checkConstSupport : f32 = 1;"}),{messages:i}=await n.compilationInfo();if(i.find((({type:e})=>"error"===e)))throw new Error("WGSL const support");return{adapter:e,device:t}})().then((({adapter:e,device:t})=>{const n=new v({device:t}),i=new P({adapter:e,camera:n,device:t}),o=new k({device:t,size:a(128,64,128)});document.getElementById("renderer").appendChild(i.canvas),i.setSize(window.innerWidth,window.innerHeight),window.addEventListener("resize",(()=>i.setSize(window.innerWidth,window.innerHeight)),!1);const s=new Y({camera:n,device:t,faces:o.faces,samples:i.samples});i.scene.push(s);const l=new w({instances:o.simulation.projectiles.instances,camera:n,device:t,samples:i.samples});i.scene.push(l);const d=new x({instances:o.simulation.explosions.instances,camera:n,device:t,geometry:l.geometry,samples:i.samples});i.scene.push(d);const m=new b({camera:n,device:t,position:a(64,6.75,64),samples:i.samples});i.scene.push(m);let g=performance.now()/1e3;document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&(g=performance.now()/1e3)}),!1);const h=new y,E=a(64,0,64);c(n.target,E[0],7,E[2]);const M=new Uint32Array([0,600,1200,1800]),B=r(),T=r(),z=r(),_=()=>{requestAnimationFrame(_);const e=performance.now()/1e3,r=Math.min(e-g,1);g=e,h.update(r),n.setOrbit(h.look.state[0],h.look.state[1],128*h.zoom.state);for(let n=0;n<4;n++){const i=e+n*Math.PI*.5,r=32+16*Math.sin(e);o.update.input.data.set([Math.floor(E[0]+Math.cos(i)*r),63,Math.floor(E[2]+Math.sin(i)*r),1+M[n]++%361],4*n),t.queue.writeBuffer(o.update.input.buffer,0,o.update.input.data)}c(T,128*(Math.random()-.5),64,128*(Math.random()-.5)),u(T,T,E),c(z,112*(Math.random()-.5),0,112*(Math.random()-.5)),u(z,z,E),f(B,z,T),p(B,B),o.simulation.shoot(B,T);const a=t.createCommandEncoder();o.update.compute(a),o.compute(a,r),i.render(a),t.queue.submit([a.finish()])};requestAnimationFrame(_)})).catch((e=>{console.error(e),document.getElementById("canary").classList.add("enabled")})).finally((()=>document.getElementById("loading").classList.remove("enabled")))}();
